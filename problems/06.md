# 06. Our first crypto primitive (hashing)

Now that we have a running bank and a threat model with a high risk target,
let's look at what we can do to mitigate this risk. As mentioned previously,
in this workshop we will be using the cryptographic library called `libsodium`,
exposed to Javascript by the `sodium-native` module. This suite of primitives
has a strong focus on being user friendly, hard to misuse and being
"high level". Many of the primitives we will be looking at here also have
equivalents in the core `crypto` module, which is based on OpenSSL.

## Side quest

`sodium-native` is a native module, which in itself can be a side quest to
install. However we, @mafintosh and @emilbayes, try hard to provide prebuilt
binaries for all major platforms and releases of node and electron. This means
you shouldn't have to compile anything when installing the module.

```sh
npm install sodium-native
```

## Buffers

One of the fundamental building blocks that make cryptography practical and
safe (and fun!) in Javascript is the core `Buffer` prototype. `Buffer`s today
are the same as `Uint8Arrays` with some extra methods to make working with them
easier. `Buffer`s in node is the closest you get to raw memory access, but in a
safe manner, so you don't have overflow bugs, like in C/C++. Below are some of
the most important `Buffer` methods that you will be using in the workshop,
namely allocating a specific number of bytes, checking for equality and
converting the Buffer back to something that is a printable string:

```js
// Creating buffers
Buffer.alloc(32) // Allocate empty 32 byte Buffer
Buffer.from('Hello world') // Allocate buffer and write 'Hello world'
Buffer.alloc(32).fill('Hello') // Allocate 32 byte Buffer and repeat 'Hello'

buf1.equals(buf2) // Check whether buf1 and buf2 are equal byte by byte

// Converting to printable strings
buf.toString('hex') // Octets in as hexadecimal
buf.toString('base64') // Octets as ascii safe string (base64)
```

Being intimate with `Buffer`s is key to working efficiently with crypto.

## Hashing

Hash functions are a class of mathematical functions that transform an arbitrary
sequence of data into a fixed size digest. The digest is also often called a
hash or a fingerprint, because the idea is that a hash function should produce
a unique result for any every unique piece of data. There are many varieties of
hash functions, but here we will only work with cryptographically secure hash
functions.

Cryptographic hash functions provide a much strong guarantee regarding the
uniqueness of the fingerprint, but at the cost of requiring more computation,
and hence, time. However for the particular hash function used by `libsodium`,
context switching from V8 to C will be a bottleneck before hashing is :)

Let's have a look at how to compute a hash with out first `libsodium` API,
`crypto_generichash`:

```js
var sodium = require('sodium-native')
// Allocate Buffer for output hash
var output = Buffer.alloc(sodium.crypto_generichash_BYTES)
// Convert input to string and then Buffer
var input = Buffer.from(JSON.stringify({cmd: 'hello'}))

// Compute blake2b hash
sodium.crypto_generichash(output, input)

// Convert bytes to printable string
console.log(output.toString('hex'))
```

You might find this way of calling functions a bit foreign, since there are so
many manual steps, like allocating the output `Buffer` and converting a
Javascript object to a string, and then converting it to a `Buffer`. But all for
a reason! As mentioned in the introduction, this is because it gives you full
control of the memory used, so if you are handling sensitive data, you can
delete it as soon as you're done touching it (using `.fill(0)`) or you can
reuse `Buffer`s in high performance scenarios. Also note that the data written
to the output `Buffer` may contain any byte, and not all bytes are ascii
friendly which is why you need to convert the `Buffer` to either `hex` or
`base64` to print it.

[Continue to problem 06](06.md)
